---
title: "GraalVM for Native Image"
search: false
category:
  - information
  - java
last_modified_at: 2023-09-09T23:55:00
---

<br/>

#### RECOMMEND POSTS BEFORE THIS

* [JVM 실행 엔진(Execution Engine)][jvm-execution-engine-link]

## 0. 들어가면서

최근 온라인으로나마 참석했던 `SpringOne` 같은 큰 세션들에서 스프링 부트(spring boot) 3.X 버전, JDK 21과 함께 `GraalVM`에 대한 이야기가 많이 들립니다. 
발표자들은 "부팅 속도가 빠르다.", "메모리가 적게 소요된다." 같은 장점들에 대해 대단하다는 듯 소개를 했지만, 들으면서 의구심이 들었습니다. 

> 그렇게 좋은 기술이라면 아직까지 프로젝트나 현업에서 접해보지 못 했을까?

어떤 기술인지, 정말 지금 바로 사용해볼만큼 성숙했는지 공부해봤습니다. 

## 1. GraalVM

> GraalVM compiles your Java applications ahead of time into standalone binaries. These binaries are smaller, start up to 100x faster, provide peak performance with no warmup, and use less memory and CPU than applications running on a Java Virtual Machine (JVM).

GraalVM은 Java 어플리케이션을 AoT(Ahead of Time) 컴파일러를 사용해 독립형 바이너리(binary) 파일을 만듭니다. 
이 한 줄을 이해한다면 GraalVM이 무슨 기술인지 대략적으로 파악할 수 있습니다. 
GraalVM이 독립형 바이너리 파일을 만든다는 의미를 먼저 살펴보겠습니다. 

### 1.1. Byte Code

Java 어플리케이션은 다음과 같은 과정을 거쳐 실행됩니다.

* 개발자가 소스 코드를 작성한다.
* 컴파일러가 소스 코드를 바이트 코드로 컴파일한다.
* JVM(Java Virtual Machine)의 인터프리터(interpreter)가 운영체제에 맞 바이트 코드를 기계어로 번역하고 실행한다.

<p align="center">
    <img src="/images/graal-vm-1.JPG" width="80%" class="image__border">
</p>

### 1.2. Native Image

사실 GraalVM이 만든다는 독립적인 바이너리 파일은 운영체제에서 직접 실행할 수 있는 기계어를 의미합니다. 
소스 코드를 운영체제가 이해할 수 있는 기계어를 직접 컴파일합니다. 
GraalVM가 컴파일을 통해 생성하는 파일은 JVM 없이 운영체제가 직접 실행할 수 있으며 이를 네이티브 이미지(native image)라고 합니다. 

* 개발자가 소스 코드를 작성한다.
* 컴파일러가 소스 코드를 기계어로 컴파일한다.
* 운영체제가 기계어를 실행한다.

<p align="center">
    <img src="/images/graal-vm-2.JPG" width="50%" class="image__border">
</p>

### 1.3. GraalVM with Native Cloud

GraalVM이 추구하는 것은 Java라는 언어가 처음 등장한 배경인 `Write Once Run Anywhere`과 정반대입니다. 
Java는 어플리케이션 코드를 작성하고 한번 빌드하면 플랫폼에 종속되지 않고 어디서든 실행시킬 수 있었습니다. 
GraalVM은 플랫폼에 최적화 된 컴파일을 수행하다보니 운영체제가 변경되면 어플리케이션을 다시 빌드해야합니다. 
예전 C, C++ 처럼 플랫폼에 종속된 컴파일 기술이 다시 등장한 배경에는 클라우드(cloud) 기술 발전이 있습니다. 

* 컨테이너의 베이스 이미지에 맞는 빌드를 수행하면 되므로 호스트 플랫폼에 종속적이지 않다. 
* 클라우드 환경에서 컨테이너가 자주 생성되고 삭제되므로 가벼운 어플리케이션, 빠른 실행이 필요하다.
* 서버리스(serverless) 기능을 사용한다.

GraalVM이 생성하는 네이티브 이미지는 이런 문제점을 해결합니다. 

* JVM이 필요한 리소스의 일부만 사용하기 때문에 실행 속도가 빠릅니다.
    * 수 밀리초(milliseconds)만에 실행됩니다.
* 네이티브 바이너리로 작성되었기 때문에 웜업(warmup) 없이 최고의 성능을 즉시 제공합니다.
* 빠르고 효율적인 배포를 위해 경량 컨테이너 이미지로 패키징이 가능합니다.
* 불필요하거나 사용하지 않는 코드들은 제거하기 때문에 공격에 대한 노출을 최소화합니다.

## 2. Compilers

GraalVM에서 사용하는 AOT(Ahead Of Time) 컴파일러가 무엇인지 알아보기 전에 JIT(Just In Time) 컴파일러를 살펴보겠습니다. 

### 2.1. Just In Time Compiler

바이트 코드는 JVM 인터프리터를 통해 매번 번역됩니다. 

### 2.2. Ahead Of Time Compiler















* Start Fast
    * Native Image Build Process
    * JIT VS VOT
    * JIT
        * Load JAR files from disk
        * Uncompress class file
        * Verify class definitions
        * Execute in interpreter(x20 slower)
        * Gather profiling feedback
        * Execute at peak performance
    * AOT
        * Load executable from disk
        * Execute at peak performance 
* Low Resource Usage
    * JIT
        * Garbage Collector
        * Virtual Machine Runtime And Compiler
        * Dynamic Code Cache
        * Metaspace Class Files
        * Profiling Feedback
        * Compiliation Data Structures
        * Application Payload
    * AOT
        * Garbage Collector
        * Application Machine Code
        * Application Payload
* Minimize Vulnerability
    * no new unknown code can be loaded at run time
    * only pahts proven reachable by the application are included in the image
    * reflection is disabled by default and needs an explicit include list
    * deserialization only enabled for specified list of classes
    * JIT crashes, wrong compilations, or JIT spraying to create machine code gadgets are impossible
* Compact Packaging
    * 
* GraalVM & Reflection
    * GraalVM은 리플렉션을 지원하지 않는다는 것은 아니다.
    * Native Image tries to resolve the target elements through a static analysis that detects calls to the reflection API
        * if the analysis can not automatically detect your use of reflection, you might need additional configuration
    * Trace reflection, JNI, resource usage on the JVM with the tracing agent
        * Manual adjustment / addition might still be necessary
    * 

## CLOSING

#### TEST CODE REPOSITORY

#### RECOMMEND NEXT POSTS

#### REFERENCE

* <https://www.youtube.com/watch?v=8umoZWj6UcU>
* <https://www.youtube.com/watch?v=C7toO3WV1NQ>
* <https://www.graalvm.org/latest/docs/introduction/>
* <https://www.graalvm.org/latest/reference-manual/native-image/>
* <https://mangkyu.tistory.com/301>
* <https://mangkyu.tistory.com/302>


* <https://velog.io/@profoundsea25/SpringBoot-3-GraalVM-Native-Image-%EC%A0%81%EC%9A%A9-%EC%8B%A4%ED%8C%A8%EB%8B%B4>
* <https://velog.io/@akfls221/Spring-GraalVM-Native-Image>
* <https://happy-jjang-a.tistory.com/191>
* <https://github.com/spring-attic/spring-native/issues/381>
* <https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html>
* <https://lab.logpresso.com/2020/05/10/graalvm>
* <https://lab.logpresso.com/2021/05/27/graalvm-native-image>
* <https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html>

[jvm-execution-engine-link]: https://junhyunny.github.io/information/java/jvm-execution-engine/