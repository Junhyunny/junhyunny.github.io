---
title: "GraalVM for Native Image"
search: false
category:
  - information
  - java
last_modified_at: 2023-09-09T23:55:00
---

<br/>

#### RECOMMEND POSTS BEFORE THIS

* [JVM 실행 엔진(Execution Engine)][jvm-execution-engine-link]

## 0. 들어가면서

최근 온라인으로나마 참석했던 `SpringOne` 같은 큰 세션들에서 스프링 부트(spring boot) 3.X 버전, JDK 21과 함께 `GraalVM`에 대한 이야기가 많이 들립니다. 
발표자들은 "부팅 속도가 빠르다.", "메모리가 적게 소요된다." 같은 장점들에 대해 대단하다는 듯 소개를 했지만, 들으면서 의구심이 들었습니다. 

> 그렇게 좋은 기술이라면 아직까지 프로젝트나 현업에서 접해보지 못 했을까?

어떤 기술인지, 정말 지금 바로 사용해볼만큼 성숙했는지 공부해봤습니다. 

## 1. GraalVM

> GraalVM compiles your Java applications ahead of time into standalone binaries. These binaries are smaller, start up to 100x faster, provide peak performance with no warmup, and use less memory and CPU than applications running on a Java Virtual Machine (JVM).

GraalVM은 Java 어플리케이션을 AoT(Ahead of Time) 컴파일러를 사용해 독립형 바이너리(binary) 파일을 만듭니다. 
이 한 줄을 이해한다면 GraalVM이 무슨 기술인지 대략적으로 파악할 수 있습니다. 
GraalVM이 독립형 바이너리 파일을 만든다는 의미를 먼저 살펴보겠습니다. 

### 1.1. Byte Code

Java 어플리케이션은 다음과 같은 과정을 거쳐 실행됩니다.

* 개발자가 소스 코드를 작성한다.
* 컴파일러가 소스 코드를 바이트 코드로 컴파일한다.
* JVM(Java Virtual Machine)의 인터프리터(interpreter)가 운영체제에 맞 바이트 코드를 기계어로 번역하고 실행한다.

<p align="center">
    <img src="/images/graal-vm-1.JPG" width="80%" class="image__border">
</p>

### 1.2. Native Image

사실 GraalVM이 만든다는 독립적인 바이너리 파일은 운영체제에서 직접 실행할 수 있는 기계어를 의미합니다. 
소스 코드를 운영체제가 이해할 수 있는 기계어를 직접 컴파일합니다. 
GraalVM가 컴파일을 통해 생성하는 파일은 JVM 없이 운영체제가 직접 실행할 수 있으며 이를 네이티브 이미지(native image)라고 합니다. 

* 개발자가 소스 코드를 작성한다.
* 컴파일러가 소스 코드를 기계어로 컴파일한다.
* 운영체제가 기계어를 실행한다.

<p align="center">
    <img src="/images/graal-vm-2.JPG" width="50%" class="image__border">
</p>

### 1.3. GraalVM with Native Cloud

GraalVM이 추구하는 것은 Java라는 언어가 처음 등장한 배경인 `Write Once Run Anywhere`과 정반대입니다. 
Java는 어플리케이션 코드를 작성하고 한번 빌드하면 플랫폼에 종속되지 않고 어디서든 실행시킬 수 있었습니다. 
GraalVM은 플랫폼에 최적화 된 컴파일을 수행하다보니 운영체제가 변경되면 어플리케이션을 다시 빌드해야합니다. 
예전 C, C++ 처럼 플랫폼에 종속된 컴파일 기술이 다시 등장한 배경에는 클라우드(cloud) 기술 발전이 있습니다. 

* 컨테이너의 베이스 이미지에 맞는 빌드를 수행하면 되므로 호스트 플랫폼에 종속적이지 않다. 
* 클라우드 환경에서 컨테이너가 자주 생성되고 삭제되므로 가벼운 어플리케이션, 빠른 실행이 필요하다.
* 서버리스(serverless) 기능을 사용한다.

GraalVM의 네이티브 이미지는 이런 문제점을 해결합니다. 

* JVM이 필요한 리소스의 일부만 사용하기 때문에 실행 속도가 빠릅니다.
    * 수 밀리초(milliseconds)만에 실행됩니다.
* 네이티브 바이너리로 작성되었기 때문에 웜업(warmup) 없이 최고의 성능을 즉시 제공합니다.
* 빠르고 효율적인 배포를 위해 경량 컨테이너 이미지로 패키징이 가능합니다.
* 불필요하거나 사용하지 않는 코드들은 제거하기 때문에 공격에 대한 노출을 최소화합니다.

## 2. Compilers

GraalVM은 두 가지 컴파일러를 사용합니다.

* Graal Compiler
    * C2 컴파일러를 대체하기 위해 Java로 개발된 Just In Time(JIT) 컴파일러
* AOT(Ahead Of Time) Compiler
    * 네이티브 이미지를 생성하는 컴파일러

### 2.1. Graal Compiler

#### 2.1.1. Just In Time Compiler

Graal 컴파일러에 대해 알아보기 전에 먼저 JIT 컴파일러를 살펴보겠습니다. 
Java 어플리케이션이 실행되면 바이트 코드는 JVM 인터프리터를 통해 매번 기계어로 번역 후 실행됩니다. 
Java가 C, C++ 같은 컴파일 언어보다 느리다는 이유는 바이트 코드를 기계어로 번역하는 과정 때문입니다. 
실행 속도의 격차를 줄이기 위해 등장한 것이 JIT 컴파일러입니다.

> In computing, just-in-time (JIT) compilation (also dynamic translation or run-time compilations) is a way of executing computer code that involves compilation during execution of a program (at run time) rather than before execution.

JIT 컴파일러는 어플리케이션 런타임 중 자주 실행되는 바이트 코드 영역을 기계어로 컴파일합니다. 
JIT 컴파일러는 디바이스 정보나 CPU 클럭 같은 프로파일링 정보를 활용한 컴파일 최적화를 수행하고, 이를 통해 Java 어플리케이션의 최고 성능(throughput)은 C, C++ 같은 컴파일 언어를 능가할 때도 있다고 합니다. 
Java 어플리케이션이 실행 초반에 속도가 느리고 웜업이 된 후 빨라지는 이유입니다. 

#### 2.1.2. Substitute JIT Compiler

GraalVM 프로젝트는 HotSpot 가상머신의 문제를 몇 가지 문제를 해결하기 위해 Java로 전용 컴파일러를 만듭니다. 
HotSpot 가상머신에서 사용하는 C1, C2 두 개의 컴파일러 중 C2를 대체할 Graal 컴파일러를 개발합니다.

* Java 기반으로 개발
    * C++ 언어를 사용하는 개발자가 줄어들어 개발, 유지보수가 어렵다.
    * 현재 Java도 충분히 빠르다.
* 어려운 C2 최적화
    * 오랜 기간 유지 보수되어 컴파일러의 복잡도가 너무 높다.
    * 거의 모든 최적화 작업을 수행하여 더이상 최적화할 수 있는 여지가 없다.

<p align="center">
    <img src="/images/graal-vm-3.JPG" width="80%" class="image__border">
</p>
<center>https://qiita.com/f6wbl6/items/e3dd175fa2fbd06bb39e</center>

### 2.2. Ahead Of Time Compiler

네이티브 이미지를 만드는 일은 


### 2.3. Compilers in OpenJDK

* [JEP 243](https://openjdk.org/jeps/243) - Java-Level JVM Compiler Interface
* [JEP 295](https://openjdk.org/jeps/295) - Ahead-of-Time Compilation
* [JEP 317](https://openjdk.org/jeps/317) - Experimental Java-Based JIT Compiler
* [JEP 410](https://openjdk.org/jeps/410) - Remove the Experimental AOT and JIT Compiler

## 3. GraalVM as a Language Platform


## CLOSING

#### TEST CODE REPOSITORY

#### RECOMMEND NEXT POSTS

#### REFERENCE

* <https://www.youtube.com/watch?v=8umoZWj6UcU>
* <https://www.youtube.com/watch?v=C7toO3WV1NQ>
* <https://www.youtube.com/watch?v=54rxc2dEv10>
* <https://2023.springio.net/docs/slides/going-native-fast-and-lightweight-spring-boot-applications-with-graalvm-alina-yurenko-springio23.pdf>
* <https://openjdk.org/jeps/410>
* <https://www.graalvm.org/latest/docs/introduction/>
* <https://www.graalvm.org/latest/reference-manual/java/compiler/>
* <https://www.graalvm.org/latest/reference-manual/native-image/>
* <https://www.graalvm.org/latest/reference-manual/native-image/metadata/Compatibility/>
* <https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/Reflection/>
* <https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/DynamicProxy/>
* <https://mangkyu.tistory.com/301>
* <https://mangkyu.tistory.com/302>
* <https://shirohoo.github.io/backend/java/2022-07-16-aot-vs-jit-in-java/>
* <https://www.baeldung.com/graal-java-jit-compiler>


* <https://velog.io/@profoundsea25/SpringBoot-3-GraalVM-Native-Image-%EC%A0%81%EC%9A%A9-%EC%8B%A4%ED%8C%A8%EB%8B%B4>
* <https://velog.io/@akfls221/Spring-GraalVM-Native-Image>
* <https://happy-jjang-a.tistory.com/191>
* <https://github.com/spring-attic/spring-native/issues/381>
* <https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html>
* <https://lab.logpresso.com/2020/05/10/graalvm>
* <https://lab.logpresso.com/2021/05/27/graalvm-native-image>
* <https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html>

[jvm-execution-engine-link]: https://junhyunny.github.io/information/java/jvm-execution-engine/