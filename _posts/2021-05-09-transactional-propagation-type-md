---
title: "Spring @Transactional And Propagtaion Type"
search: false
category:
  - spring-boot
  - jpa
  - junit
last_modified_at: 2021-05-09T00:00:00
---

<br>

기본적으로 트랜잭션은 [ACID 특징][transaction-acid-link]을 만족해야합니다. 
> 트랜잭션 ACID 특징 중 원자성(Atomic)<br>
> 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장합니다.<br>
> All or Noting의 개념으로서 작업 단위의 일부분만 실행하지 않는다는 것을 의미합니다.

Spring Boot 프레임워크은 어플리케이션이 트랜잭션 원자성을 만족시킬 수 있도록 **`@Transactional`** 애너테이션을 제공합니다. 
**`@Transactional`** 애너테이션이 제공하는 기능과 트랜잭션 전파 타입(propagation type)에 대해 정리해보았습니다.  

## @Transactional 애너테이션
Spring 프레임워크는 AOP(Aspect Oriented Programming) 기능을 지원합니다. 
AOP 기능이란 특정 시점의 동작을 가로채어 해당하는 동작의 앞, 뒤로 필요한 기능을 수행하는 프로그래밍 방식입니다. 
Spring 프레임워크는 개발자가 트랜잭션에 대한 제어를 쉽게 처리할 수 있도록 AOP 기능과 애너테이션을 이용합니다. 

##### AOP 기능을 이용한 트랜잭션 처리 개념도
<p align="center"><img src="/images/transactional-propagation-type-1.JPG" width="80%"></p>

##### @Transactional 애너테이션 적용 메소드 호출 시 Call Stack
- 디버그를 통해 확인
<p align="center"><img src="/images/transactional-propagation-type-2.JPG" width="80%"></p>

주의할 사항으로 AOP 기능은 Spring 프레임워크에서 관리하는 빈(Bean)에게만 적용할 수 있습니다. 
new 키워드를 이용해 만든 객체의 메소드에 @Transactional 애너테이션이 붙어 있더라도 정상적으로 동작하지 않습니다. 
가능한 방법이 있는 듯 하지만 이번 포스트에서는 다루지 않겠습니다. 

##### 빈(Bean)이 아닌 객체 @Transactional 애너테이션 적용 시 
<p align="center"><img src="/images/transactional-propagation-type-3.JPG" width="80%"></p>

##### 빈(Bean)이 아닌 객체 @Transactional 애너테이션 적용 메소드 호출 시 Call Stack
- 디버그를 통해 확인
<p align="center"><img src="/images/transactional-propagation-type-4.JPG" width="80%"></p>

### @Transactional 애너테이션 적용 가능 위치
@Transactional 애너테이션을 살펴보면 @Target이 TYPE, METHOD 임을 확인할 수 있습니다. 
각 타입 별 적용 가능 범위입니다.
- ElementType.TYPE - Class, interface (including annotation type), or enum declaration
- ElementType.METHOD - Method declaration

메소드에 @Transactional 애너테이션을 적용하는 경우는 명확합니다. 
클래스에 적용하는 경우 모든 public 메소드에 적용되며, private, protected 메소드에는 적용되지 않습니다. 

> StackOverflow<br>
> Spring applies the class-level annotation to all public methods of this class that we did not annotate with @Transactional. 
> However, if we put the annotation on a private or protected method, Spring will ignore it without an error.

##### @Transactional 애너테이션 코드
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
  ...
}
```

## 트랜잭션 전파 타입(Propagation Type)
트랜잭션의 전파 타입은 총 7개 존재합니다. 각 타입 별로 기능에 대해 정리하였습니다.
- REQUIRED
  - Support a current transaction, create a new one if none exists.
  - 현재 트랜잭션을 유지하고, 진행 중인 트랜잭션이 없으면 새로 만듭니다.
- SUPPORTS
  - Support a current transaction, execute non-transactionally if none exists.
  - 현재 트랜잭션을 유지하고, 진행 중인 트랜잭션이 없으면 트랜잭션을 만들지 않습니다. 
- MANDATORY
  - Support a current transaction, throw an exception if none exists.
  - 현재 트랜잭션을 유지하고, 진행 중인 트랜잭션이 없으면 exception을 던집니다.
- REQUIRES_NEW
  - Create a new transaction, and suspend the current transaction if one exists.
  - 새로운 트랜잭션을 만듭니다. 진행 중인 트랜잭션이 있다면 이를 일시 중단합니다.
- NOT_SUPPORTED
  - Execute non-transactionally, suspend the current transaction if one exists.
  - 트랜잭션 없이 수행합니다. 진행 중인 트랜잭션이 있다면 이를 일시 중단합니다.
- NEVER
  - Execute non-transactionally, throw an exception if a transaction exists.
  - 트랜잭션 없이 수행합니다. 진행 중인 트랜잭션이 있다면 exception을 던집니다.
- NESTED
  - Execute within a nested transaction if a current transaction exists, behave like {@code REQUIRED} otherwise.
  - 현재 트랜잭션이 있으면 중첩 트랜잭션 내에서 실행하고, 그렇지 않으면 REQUIRED 처럼 동작합니다.

역시 글로만 정리하면 이해가 어렵습니다. 
각 전파 타입 별로 간단한 테스트 코드와 이미지를 이용해 이해도를 높혀보겠습니다. 

### REQUIRED

### SUPPORTS

### MANDATORY

### REQUIRES_NEW

### NOT_SUPPORTED

### NEVER

### NESTED

## OPINION
작성 중 입니다.

#### REFERENCE
- <https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html>
- <https://stackoverflow.com/questions/23132822/what-is-the-difference-between-defining-transactional-on-class-vs-method>
- <https://www.nextree.co.kr/p3180/>

[transaction-acid-link]: https://junhyunny.github.io/information/transcation-acid/