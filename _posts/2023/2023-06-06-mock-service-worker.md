---
title: "목 서비스 워커 (Mock Service Worker)"
search: false
category:
  - information
  - react
  - test-driven-development
last_modified_at: 2026-01-27T23:55:00
---

<br/>

#### RECOMMEND POSTS BEFORE THIS

- [테스트 더블(Test Double)][test-double-link]
- [React 환경 변수 설정과 실행 환경 분리][react-env-variable-setting-link]
- [Service Worker][service-worker-api-link]

## 1. Mock Service Worker

목 서비스 워커(MSW, Mock Service Worker)는 이름처럼 [서비스 워커(Service Worker)][service-worker-api-link]의 [테스트 더블(test double)][test-double-link]을 의미한다. API 모킹(mocking)을 지원하는 라이브러리이며 서버로 보내는 네트워크 요청을 가로채어 모의 응답을 내려준다. 서비스 워커가 무엇이고 어떤 동작을 하는지 안다면 목 서비스 워커를 이해하는데 도움이 된다. 먼저 서비스 워커에 대해 간단하게 알아본다.

### 1.1. Service Worker

> 브라우저에서 실행되는 백그라운드 스크립트이며 브라우저와 서버 사이에서 요청과 응답을 처리할 수 있는 네트워크 프록시(proxy)이다.

서비스 워커는 웹 애플리케이션과 독립적으로 동작하는 스크립트이다. 서비스 워커 역할을 수행할 수 있는 JavaScript 파일을 브라우저에 등록만 하면 사용할 수 있다. 웹 애플리케이션에서 간단한 코드를 통해 서비스 워커를 설치할 수 있다. 서비스 워커는 대표적으로 다음과 같은 기능을 제공한다.

- 오프라인 브라우징(offline browsing)
- 백그라운드 동기화
- 푸시 알림

서비스 워커가 이런 기능들을 제공할 수 있는 이유는 다음과 같다.

- 이벤트 기반으로 동작하며 웹 애플리케이션에서 수행하는 네트워크 요청 이벤트를 가로챌 수 있다.
- 브라우저 캐시 저장소(cache storage)를 사용할 수 있으며 오프라인 상태에서 캐시에 저장된 리소스를 사용할 수 있다.
- 설치를 통해 백그라운드에서 별도로 동작할 수 있다.

<div align="center">
  <img src="/images/posts/2023/mock-service-worker-01.png" width="80%" class="image__border">
</div>

### 1.2. How does Mock Service Worker work? 

목 서비스 워커는 브라우저 환경에서 다음과 같은 방법으로 동작한다. 플로우 다이어그램(flow diagram)에는 브라우저로 표현되어 있지만, 더 정확한 표현은 웹 애플리케이션이라고 생각되어 명칭을 바꿔 설명한다.

1. 웹 애플리케이션에서 서버로 요청을 보낸다.
  - 서비스 워커가 웹 애플리케이션의 요청을 가로챈다.
  - 서비스 워커는 네트워크 요청을 fetch 이벤트 콜백 함수를 통해 가로챌 수 있다.
2. 요청 정보를 목 서비스 워커에게 복사하여 전달한다.
3. 목 서비스 워커는 해당 요청에 매칭되는 사전에 정의한 핸들러(handler)를 실행한다.
4. 서비스 워커는 목 서비스 워커로부터 모의 응답을 전달받는다.
5. 서비스 워커는 모의 응답을 웹 애플리케이션에 전달한다.

<div align="center">
  <img src="/images/posts/2023/mock-service-worker-02.png" width="80%" class="image__border">
</div>
<center>https://mswjs.io/docs/#request-flow-diagram</center>

## 2. Practice

간단한 TODO 리스트 애플리케이션 예시를 통해 목 서비스 워커의 사용 방법을 알아본다.

CRA(Create React App)을 통해 프로젝트를 생성하였으며 전체적인 구조는 다음과 같다. 

```
./
├── README.md
├── package-lock.json
├── package.json
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   ├── mockServiceWorker.js
│   └── robots.txt
├── src
│   ├── App.css
│   ├── App.test.tsx
│   ├── App.tsx
│   ├── index.css
│   ├── index.tsx
│   ├── logo.svg
│   ├── mocks
│   │   ├── browser.ts
│   │   ├── handlers.ts
│   │   └── server.ts
│   ├── react-app-env.d.ts
│   ├── reportWebVitals.ts
│   ├── setupTests.ts
│   └── types
│       └── Todo.ts
├── tsconfig.json
└── yarn.lock
```

프로젝트 경로에서 아래 명령어를 통해 목 서비스 워커 API 의존성을 설치한다.

```
$ yarn add msw --dev

yarn add v1.22.17
warning package-lock.json found. Your project contains lock files generated by tools other than Yarn. It is advised not to mix package managers in order to avoid resolution inconsistencies caused by unsynchronized lock files. To clear this warning, remove package-lock.json.
[1/4] 🔍  Resolving packages...
[2/4] 🚚  Fetching packages...
[3/4] 🔗  Linking dependencies...
warning " > @testing-library/user-event@13.5.0" has unmet peer dependency "@testing-library/dom@>=7.21.4".
warning "react-scripts > eslint-config-react-app > eslint-plugin-flowtype@8.0.3" has unmet peer dependency "@babel/plugin-syntax-flow@^7.14.5".
warning "react-scripts > eslint-config-react-app > eslint-plugin-flowtype@8.0.3" has unmet peer dependency "@babel/plugin-transform-react-jsx@^7.14.9".
[4/4] 🔨  Building fresh packages...
success Saved 1 new dependency.
info Direct dependencies
└─ msw@1.2.1
info All dependencies
└─ msw@1.2.1
✨  Done in 17.52s.
```

### 2.1. Mock Service Worker setting

리액트 애플리케이션의 테스팅 프레임워크인 `jest`는 노드(node) 환경에서 동작한다. 런타임 시 브라우저에 목 서비스 워커를 설치하는 방법과 다르므로 이를 주의하길 바란다.

먼저 모의 응답을 만드는 핸들러를 정의한다. 프로젝트 `src/mocks` 경로에 생성한다.

- `/todos` GET 요청
  - 기존에 저장된 TODO 리스트를 모의 응답한다.
- `/todos` POST 요청
  - 요청을 통해 전달받은 내용으로 새로운 TODO를 생성한다.
  - 신규 TODO가 생성되었다고 가정하고 임의의 아이디와 함께 신규 TODO를 모의 응답한다.

```ts
import { rest } from "msw";
import { Todo } from "../types/Todo";

export const handlers = [
  rest.get("/todos", (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([
        { id: 1, content: "Frontend Study" },
        { id: 2, content: "Backend Study" },
      ])
    );
  }),
  rest.post("/todos", async (req, res, ctx) => {
    const { content } = (await req.json()) as Todo;
    return res(
      ctx.status(200),
      ctx.json({
        id: Math.floor(Math.random() * 1000000 + 1),
        content: content,
      })
    );
  }),
];
```

다음으로 목 서비스 워커를 사용해 모의 서버 객체를 생성한다. 프로젝트 `src/mocks` 경로에 생성한다.

- 생성한 핸들러를 사용하여 모의 서버 객체를 생성한다.
- 개발 서버 환경에서 사용하는 함수인 setupWorker()와 다르므로 주의한다.

```ts
import { setupServer } from "msw/node";
import { handlers } from "./handlers";

export const server = setupServer(...handlers);
```

이전 단계에서 생성한 서버 객체를 테스트 코드 실행 시 사용할 수 있도록 테스트 환경 셋업(setup) 스크립트에 아래 코드를 추가한다.

- beforeAll() 함수를 통해 테스트 시작 전에 서버를 실행한다.
- afterEach() 함수를 통해 각 테스트 완료 후에 핸들러를 초기화하여 각 테스트 사이의 상태 커플링(state coupling)을 방지한다.
- afterAll() 함수를 통해 모든 테스트 완료 후에 서버를 종료한다.

```ts
import "@testing-library/jest-dom";
import {server} from "./mocks/server";

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

### 2.2. Mock Service Worker for test

간단한 TODO 리스트 애플리케이션으로 목 서비스 워커를 사용한 테스트 코드를 작성해보자. 먼저 테스트 대상이 될 구현 코드를 살펴본다.

- 이전에 작성한 TODO 항목들을 화면에 표시한다.
- 신규 TODO를 추가하면 서버로 저장 요청 후 정상적인 응답을 받는 경우 화면에 추가한다.

```tsx
import React, { useEffect, useRef, useState } from "react";
import "./App.css";
import axios from "axios";
import { Todo } from "./types/Todo";

function App() {
  const todoTextInputRef = useRef<HTMLInputElement>(null);
  const [todoList, setTodoList] = useState<Todo[]>([]);

  useEffect(() => {
    axios.get("/todos").then((response) => {
      const { data: todoList } = response;
      setTodoList(todoList);
    });
  }, []);

  const addHandler = async () => {
    const { data: newTodo } = await axios.post("/todos", {
      content: todoTextInputRef.current?.value,
    });
    setTodoList((todoList) => [...todoList, newTodo]);
    todoTextInputRef.current!.value = "";
  };

  return (
    <div className="app">
      <div className="todo-list">
        <div>
          {todoList.map((todo) => (
            <li key={todo.id}>{todo.content}</li>
          ))}
        </div>
      </div>
      <div className="todo-form">
        <input ref={todoTextInputRef} type="text" placeholder="NEW TODO" />
        <button onClick={addHandler}>ADD</button>
      </div>
    </div>
  );
}

export default App;
```

아래 단위 테스트는 다음과 같은 기능들을 테스트한다. 목 서비스 워커가 모의 응답을 제공하기 때문에 별도로 axios 모듈을 스터빙(stubbing)하지 않아도 된다. 해당 테스트는 정상적으로 통과한다. 

- renders todo list test
  - 기존에 작성된 TODO 리스트가 랜더링 시 화면에 보이는지 확인한다.
- add new todo test
  - 새로운 TODO를 추가하는 버튼을 클릭하면 리스트에 추가되고 입력창은 정리되는지 확인한다.

```tsx
import React from "react";
import App from "./App";

import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

test("renders todo list", async () => {
  render(<App />);

  expect(await screen.findByText("Frontend Study")).toBeInTheDocument();
  expect(screen.getByText("Backend Study")).toBeInTheDocument();
});

test("add new todo", async () => {
  render(<App />);

  await userEvent.type(screen.getByPlaceholderText("NEW TODO"), "DevOps Study");
  await userEvent.click(screen.getByText("ADD"));

  expect(await screen.findByText("DevOps Study")).toBeInTheDocument();
  expect(screen.getByPlaceholderText("NEW TODO")).toHaveValue("");
});
```

### 2.3. Mock Service Worker for development runtime

목 서비스 워커는 백엔드 서비스가 아직 구성되어 있지 않은 경우에도 활용할 수 있다. 리액트 애플리케이션을 로컬 개발 서버로 실행할 때 목 서비스 워커는 백엔드 서비스를 임시로 대체한다. 위에서 단위 테스트를 위해 정의한 핸들러와 동일한 코드를 사용하므로 핸들러 코드 설명은 제외한다. 프로젝트 `src/mocks` 경로에 생성한다.

- 생성한 핸들러를 사용하여 목 서비스 워커 객체를 생성한다.
- 테스트 환경에서 사용하는 함수인 setupServer()와 다르므로 주의한다.

```ts
import { handlers } from "./handlers";
import { setupWorker } from "msw";

export const worker = setupWorker(...handlers);
```

리액트 애플리케이션이 실행될 때 개발 서버에서만 목 서비스 워커가 함께 실행되도록 아래 코드를 추가한다.

- 개발 서버로 애플리케이션을 실행하면 `NODE_ENV` 환경 변수는 `development`이므로 이를 확인한다.

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

if (process.env.NODE_ENV === "development") {
  const { worker } = require("./mocks/browser");
  worker.start();
}

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

reportWebVitals();
```

[Service Worker][service-worker-api-link]에서 설명한 것처럼 서비스 워커는 별도의 스크립트 파일이 필요하다. MSW 라이브러리는 npx 명령어를 통해 서비스 워커 스크립트 파일 다운로드를 쉽게 제공한다. 아래 명령어를 실행하면 public 경로에 `mockServiceWorker.js` 스크립트 파일을 다운로드 받는다.

```
$ npx msw init public/ --save

Initializing the Mock Service Worker at "/Users/junhyunk/Desktop/2023-06-06-mock-service-worker/action-in-blog/public"...

Service Worker successfully created!
/Users/junhyunk/Desktop/2023-06-06-mock-service-worker/action-in-blog/public/mockServiceWorker.js

Continue by creating a mocking definition module in your application:

https://mswjs.io/docs/getting-started/mocks

$ ls -al public/

total 88
drwxr-xr-x   9 junhyunk  staff   288 Jun  7 00:42 .
drwxr-xr-x  12 junhyunk  staff   384 Jun  6 22:31 ..
-rw-r--r--   1 junhyunk  staff  3870 Jun  6 21:22 favicon.ico
-rw-r--r--   1 junhyunk  staff  1721 Jun  6 21:22 index.html
-rw-r--r--   1 junhyunk  staff  5347 Jun  6 21:22 logo192.png
-rw-r--r--   1 junhyunk  staff  9664 Jun  6 21:22 logo512.png
-rw-r--r--   1 junhyunk  staff   492 Jun  6 21:22 manifest.json
-rw-r--r--   1 junhyunk  staff  8133 Jun  7 00:42 mockServiceWorker.js
-rw-r--r--   1 junhyunk  staff    67 Jun  6 21:22 robots.txt
```

개발 서버를 실행한 후 접속하면 핸들러에 미리 추가한 모의 응답들을 브라우저 화면에서 확인할 수 있다. 신규 TODO 추가도 정상적으로 동작한다.

- 등록된 서비스 워커 정보는 `개발자 도구(F12) > 애플리케이션 > Service Workers`에서 확인할 수 있다.
- 콘솔 로그에 목 서비스 워커 동작과 관련된 로그가 출력된다.

<div align="center">
  <img src="/images/posts/2023/mock-service-worker-03.gif" width="100%" class="image__border">
</div>

## CLOSING

목 서비스 워커를 사용하면 프론트엔드 개발 시 마주치는 문제들을 해결할 수 있을 것 같다.

- 백엔드 서비스 개발이 되지 않은 상태에서 API 관련된 기능을 개발할 수 있다.
- 프론트엔드 테스트 코드 작성 시 중복되는 스텁들을 핸들러 파일에서 공동으로 관리할 수 있다.

API 응답을 위한 스텁의 경우 화면의 기능에 따라 커지거나 많아지기 때문에 테스트 코드를 보기 어려워진다. 비즈니스 단위로 핸들러를 만들고 적절한 모의 응답들을 반환한다면 테스트 코드를 짧고 간결하게 유지할 수 있다. 

#### TEST CODE REPOSITORY

- <https://github.com/Junhyunny/blog-in-action/tree/master/2023-06-06-mock-service-worker>

#### REFERENCE

- <https://mswjs.io/>
- <https://mswjs.io/docs/#request-flow-diagram>
- <https://www.daleseo.com/mock-service-worker/>
- <https://blog.rhostem.com/posts/2021-03-20-mock-service-worker>

[test-double-link]: https://junhyunny.github.io/test/test-driven-development/test-double/
[react-env-variable-setting-link]: https://junhyunny.github.io/react/react-env-variable-setting/
[service-worker-api-link]: https://junhyunny.github.io/information/service-worker-api/